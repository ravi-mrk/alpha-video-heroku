function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _ = require("lodash");

var Assertion = require("./Assertion");

var Configuration = require("../runner/Configuration");

var Expression = require("./Expression");

var fs = require("fs");

var ParserError = require("./ParserError");

var Test = require("./Test");

var TestInteraction = require("./TestInteraction");

var TestSuite = require("./TestSuite");

var Util = require("../util/Util");

var yaml = require("js-yaml-bespoken");
/**
 * Represents the parser used for converting a yaml file into a test suite
 */


var TestParser = /*#__PURE__*/function () {
  /**
   *
   * @param {string} fileName - the yaml file that will be parsed
   */
  function TestParser(fileName) {
    _classCallCheck(this, TestParser);

    this.fileName = fileName;

    if (this.fileName) {
      this.contents = fs.readFileSync(this.fileName, "utf8");
    }
  }
  /**
   * Set the contents of the YML file
   * @param {object} contents - set the contents of the file
   */


  _createClass(TestParser, [{
    key: "load",
    value: function load(contents) {
      this.contents = contents;
    }
    /**
     * Add quotes to string if not a regex
     * @param {string} origin - original string
     * @return {string} string with quotes
     */

  }, {
    key: "addQuotesToNonRegexString",
    value: function addQuotesToNonRegexString(origin) {
      if (origin.startsWith && origin.startsWith("/")) {
        return origin;
      }

      return `"${origin}"`;
    }
    /**
     * loads a yaml object into a yaml file
     * @param {object} yamlObject - yaml representation of a yaml file
     */

  }, {
    key: "loadYamlObject",
    value: function loadYamlObject(yamlObject) {
      var configuration = yamlObject.configuration;
      var tests = yamlObject.tests;
      this.contents = "";

      if (configuration) {
        this.contents += "---\nconfiguration:\n";
        this.contents += Object.keys(configuration).map(key => `  ${key}: ${configuration[key]}`).join("\n");
      }

      if (tests && tests.length) {
        for (var i = 0; i < tests.length; i++) {
          var testContent = "";

          if (i === 0 && this.contents === "") {
            testContent = "---\n";
          } else {
            testContent = "\n---\n";
          }

          var testSuffix = tests[i].only ? ".only" : tests[i].skip ? ".skip" : "";
          testContent += `- test${testSuffix} : ${tests[i].name}\n`;
          testContent += tests[i].interactions.map(interaction => {
            var expected = interaction.expected;
            var expressions = interaction.expressions;
            var hasExpressions = expressions && expressions.length > 0;

            if (expected.length === 1 && expected[0].action === "prompt" && !Array.isArray(expected[0].value) && !hasExpressions) {
              return `- ${interaction.input} ${expected[0].operator} ${this.addQuotesToNonRegexString(expected[0].value)}\n`;
            }

            var interactionString = `- ${interaction.input} :\n`;
            interactionString += expected.map(item => {
              if (!Array.isArray(item.value)) {
                return `  - ${item.action} ${item.operator} ${this.addQuotesToNonRegexString(item.value)}\n`;
              }

              var value = item.value.map(itemValue => `    - ${this.addQuotesToNonRegexString(itemValue)}`).join("\n");
              return `  - ${item.action} ${item.operator}\n${value}\n`;
            }).join("");

            if (expressions && expressions.length) {
              interactionString += expressions.map(item => {
                if (!Array.isArray(item.value)) {
                  return `  - ${item.path} : ${Util.isString(item.value) ? this.addQuotesToNonRegexString(item.value) : item.value}\n`;
                }

                var value = item.value.map(itemValue => `    - ${Util.isString(itemValue) ? this.addQuotesToNonRegexString(itemValue) : itemValue}`).join("\n");
                return `  - ${item.path} :\n${value}\n`;
              }).join("");
            }

            return interactionString;
          }).join("");
          this.contents += testContent;
        }
      }

      if (this.contents.includes(" : \"\"\n-")) {
        this.contents = this.contents.replace(/ : ""\n-/gi, "\n-");
      }

      if (this.contents.includes(" : \"\"\n")) {
        this.contents = this.contents.replace(/ : ""\n/gi, "\n");
      }
    }
    /**
     * Parses a test file and returns a test suite
     * @param {string} configurationOverride - configuration override for the test suite
     * @return {TestSuite}
     */

  }, {
    key: "parse",
    value: function parse(configurationOverride) {
      try {
        var contents = this.findReplace(this.contents);
        var documents = yaml.loadAll(contents);
        var configuration;
        var tests = documents;

        if (documents.length > 1 && documents[0].configuration) {
          if (!Util.isObject(documents[0].configuration)) {
            throw ParserError.globalError(this.fileName, "Configuration element is not an object", Util.extractLine(documents[0].configuration));
          }

          configuration = _.assign(documents[0].configuration, configurationOverride);
          tests = documents.slice(1);
        } else {
          configuration = configurationOverride;
        }

        var suite = new TestSuite(this.fileName, configuration);
        suite.tests = this.parseTests(suite, tests);
        suite.rawTestContent = this.contents;
        return suite;
      } catch (e) {
        throw e;
      }
    }
    /**
     * Parses the tests section of the yaml test file
     * @param {TestSuite} suite - the complete test suite
     * @param {object} rawTests - the raw tests from the yaml file
     * @return {Test[]}
     */

  }, {
    key: "parseTests",
    value: function parseTests(suite, rawTests) {
      var tests = [];
      var testNames = {};
      var testCount = 0;

      for (var test of rawTests) {
        testCount++;
        var parsedTest = this.parseTest(suite, test, testCount);

        if (parsedTest) {
          var currentTestDescription = parsedTest.description;

          if (testNames[currentTestDescription]) {
            testNames[currentTestDescription] = testNames[currentTestDescription] + 1;
            parsedTest.description = currentTestDescription + " (" + testNames[currentTestDescription] + ")";
          } else {
            testNames[currentTestDescription] = 1;
          }

          tests.push(parsedTest);
        }
      }

      return tests;
    }
    /**
     * Parses a single test of the yaml test file
     * @param {TestSuite} suite - the complete test suite
     * @param {object} rawTest - a single raw test from the yaml file
     * @param {number} testIndex - the index of which test we are parsing
     * @return {Test}
     */

  }, {
    key: "parseTest",
    value: function parseTest(suite, rawTest, testIndex) {
      //If this is not an array, skip it
      if (!Array.isArray(rawTest)) {
        return undefined;
      } // The rawTest element is just an array of interactions
      // Optionally preceded by metadata about the test


      var rawInteractions = rawTest;

      if (rawInteractions.length == 0) {
        return new Test(suite, undefined, []);
      } // We need to pull out the first key of the first line of the test
      // If there is any metadata, this is where it is


      var testMeta = "Test " + testIndex;
      var only = false;
      var skipped = false;
      var tags = [];
      var filteredInteractions = [];

      for (var i = 0; i < rawInteractions.length; i++) {
        var isSpecialInteraction = false;
        var currentInteraction = rawInteractions[i];
        var interactionKeys = Object.keys(currentInteraction); // If the first or second element of the first interaction is "test", "test.only", or "test.skip", it is metadata

        if (i < 2 && interactionKeys.length > 0 && ["test", "test.only", "test.skip"].includes(interactionKeys[0])) {
          isSpecialInteraction = true;
          testMeta = currentInteraction[interactionKeys[0]];

          if (interactionKeys[0] === "test.only") {
            only = true;
          } else if (interactionKeys[0] === "test.skip") {
            skipped = true;
          }
        } // If the first or second element of the first interaction is "tag", it is metadata


        if (i < 2 && interactionKeys.length > 0 && ["tags"].includes(interactionKeys[0])) {
          isSpecialInteraction = true;
          var tagsString = currentInteraction[interactionKeys[0]];

          if (Util.isString(tagsString)) {
            tags = tagsString.split(",").map(tag => tag.trim());
          }
        }

        if (!isSpecialInteraction) {
          filteredInteractions.push(currentInteraction);
        }
      }

      var test = new Test(suite, testMeta, []);

      for (var _i = 0; _i < filteredInteractions.length; _i++) {
        var rawInteraction = filteredInteractions[_i];
        test.interactions.push(this.parseInteraction(test, rawInteraction, _i));
      }

      test.skip = skipped;
      test.only = only;

      if (tags.length) {
        test.tags = tags;
      }

      test.validate();
      return test;
    }
    /**
     * Parse a single interaction
     * @param {Test} test - the Test the contains the interaction being parsed
     * @param {object|string} interactionJSON - the interaction being parsed
     * @param {number} index - the index of the interaction in the test
     * @return {TestInteraction}
     */

  }, {
    key: "parseInteraction",
    value: function parseInteraction(test, interactionJSON, index) {
      var interaction = new TestInteraction(test); // If we have an object, we process it - alternatively the interaction could just be a string
      //  Such as "- yes" without any assertions

      if (Util.isObject(interactionJSON)) {
        interaction.utterance = Object.keys(interactionJSON)[0];
        var elements = interactionJSON[interaction.utterance];
        interaction.lineNumber = Util.extractLine(elements); // Just because we have an object, we might have a "bad" object
        // Like so: - yes: "okay" - our old-style syntax
        // We just ignore these cases for now

        if (Array.isArray(elements)) {
          for (var element of elements) {
            if (Util.isValueType(element)) {
              var {
                assertion
              } = this.parseStringAssertion(interaction, element);

              if (assertion) {
                interaction.assertions.push(assertion);
              }
            } else {
              if (element.intent) {
                interaction.intent = element.intent.valueOf(); // Treat any other keys as slots

                var slots = Util.cleanObject(element);
                delete slots.intent;
                interaction.slots = slots;
              } else if (element.slots) {
                interaction.slots = Util.cleanObject(element.slots);
              } else if (element.label) {
                interaction.label = Util.cleanObject(element.label);
              } else if (Expression.isExpression(element)) {
                interaction.expressions.push(new Expression(element));
              } else {
                // Must be an assertion otherwise
                interaction.assertions.push(this.parseObjectAssertion(interaction, element));
              }
            }
          }
        } else if (elements) {
          var operator = "==";

          if (Util.isString(elements) && elements.startsWith("/")) {
            operator = "=~";
          }

          interaction.assertions.push(new Assertion(interaction, "prompt", operator, elements, this.getDefinedVariables(elements), ":"));
        }
      } else {
        var {
          utterance,
          assertion: _assertion
        } = this.parseStringAssertion(interaction, interactionJSON, true);
        interaction.utterance = utterance;
        interaction.lineNumber = Util.extractLine(interactionJSON);

        if (_assertion) {
          interaction.assertions.push(_assertion);
        }
      }

      interaction.relativeIndex = index;
      return interaction;
    }
    /**
     * Parses a single Assertion inside an interaction
     * @param {TestInteraction} interaction - the interaction where this assertion is used
     * @param {object} element - the object representation of the YAML element
     * @return {Assertions}
     */

  }, {
    key: "parseObjectAssertion",
    value: function parseObjectAssertion(interaction, element) {
      // Should have just one key
      var path = Object.keys(element)[0];
      var value = element[path];
      var operator = "=="; // If the value starts with /, then it must be regular expression

      if (Util.isString(value) && value.trim().startsWith("/")) {
        operator = "=~";
      } else if (Array.isArray(value)) {
        if (value.some(x => Util.isString(x) && x.trim().startsWith("/"))) {
          operator = "=~";
        }
      }

      var variablesMerged = [];
      var values = [];

      if (Array.isArray(value)) {
        for (var _element of value) {
          values.push(_element);
        }

        variablesMerged = values.reduce((variables, singleValue) => {
          var extractedVariables = this.getDefinedVariables(singleValue);
          return variables.concat(extractedVariables);
        }, []);
      } else {
        variablesMerged = this.getDefinedVariables(value + "");
      }

      var assertion = new Assertion(interaction, path, operator, value, _.uniq(variablesMerged), ":");
      assertion.validate();
      assertion.lineNumber = Util.extractLine(value);
      return assertion;
    }
    /**
     * Parse a string into assertion object.
     * Our short syntax is not valid in YAML. We look for an operator inside the string
     * Examples:
     * Hi
     * exit
     * LaunchRequest != hi
     * cardTitle != hi
     * cardTitle != - Value1 - Value2 - Value2
     *
     * @param {TestInteraction} interaction - the interaction that includes this assertion
     * @param {string} assertionString - the assertion as a string
     * @param {boolean} isUtteranceIncluded - if isUtteranceIncluded is set to true, the first part of the string will
     * will be considered as an utterance
     * @return {Assertion}
     */

  }, {
    key: "parseStringAssertion",
    value: function parseStringAssertion(interaction, assertionString, isUtteranceIncluded = false) {
      var path;
      var operator;
      var value;
      var utterance = undefined;
      var assertion = undefined;

      if (typeof assertionString === "number") {
        assertionString = assertionString + "";
      } // Special handling for exit


      if (assertionString.trim() === "exit") {
        return {
          assertion: new Assertion(interaction, "exit")
        };
      } // if utterance is not included, string with empty spaces is invalid 


      if (!isUtteranceIncluded && assertionString.indexOf(" ") === -1) {
        throw ParserError.interactionError(interaction, "Invalid assertion: " + assertionString, Util.extractLine(assertionString));
      }

      operator = this.getOperator(assertionString, isUtteranceIncluded);

      if (operator) {
        var parts = assertionString.split(operator);
        path = isUtteranceIncluded ? "prompt" : parts[0].trim(); // if utterance include, path set to prompt

        utterance = isUtteranceIncluded ? parts[0].trim() : undefined;
        value = parts[1].trim();
        operator = operator.trim(); // YAML collections get parsed as string when using our operators
        // Ex: - Value1 - Value2 - Value2
        // checking if is a collection 

        var missingParsedCollection = value.split("-").map(x => x.trim()).filter(x => x);

        if (missingParsedCollection.length > 1) {
          value = missingParsedCollection;
        }
      } else {
        utterance = assertionString;
      }

      if (operator) {
        // We only look for variables in the values (not the path)
        var variables = this.getDefinedVariables(value + "");
        assertion = new Assertion(interaction, path, operator, value, variables, operator);
        assertion.lineNumber = Util.extractLine(assertionString);
        assertion.validate();
      }

      return {
        assertion,
        utterance
      };
    }
    /**
     * returns the operator used inside the assertion
     * @param {string} assertionString - the assertion as a string
     * @param {boolean} isUtteranceIncluded - if isUtteranceIncluded is set to true, the first part of the string will
     * be considered as an utterance
     * @return {string}
     */

  }, {
    key: "getOperator",
    value: function getOperator(assertionString, isUtteranceIncluded) {
      var operators = [" == ", " =~ ", " != ", " >= ", " <= ", " > ", " < "];
      var operatorPosition = -1;
      var operator = undefined;

      for (var i = 0; i < operators.length; i++) {
        operatorPosition = assertionString.indexOf(operators[i]);

        if (operatorPosition > -1) {
          operator = operators[i];
          break;
        }
      } // if we don't find our operators, we will search for invalid ones
      // assertion object will validate the invalid ones
      // only applies when the utterance is not included


      if (!operator && !isUtteranceIncluded) {
        var parts = assertionString.split(/ +/);
        operator = parts[1];
      }

      return operator;
    }
    /**
     * Replaces constants set in the configuration which the actual values
     * @param {string} script - the yaml file as a string
     * @return {string}
     */

  }, {
    key: "findReplace",
    value: function findReplace(script) {
      var findReplaceMap = Configuration.instance() && Configuration.instance().findReplaceMap();
      if (!findReplaceMap) return script;

      for (var find of Object.keys(findReplaceMap)) {
        var value = findReplaceMap[find];
        script = script.split(find).join(value);
      }

      return script;
    }
    /**
     * Gets the different variables that needs to be replaced
     * @param {string} assertion - the yaml file as a string
     * @return {string[]} the defined variables
     */

  }, {
    key: "getDefinedVariables",
    value: function getDefinedVariables(originalAssertion) {
      var variables = []; // cloning the assertion to ensure we are not mutating it inside

      var assertion = originalAssertion + "";
      var startIndex = -1;

      do {
        startIndex = assertion.indexOf("{");

        if (startIndex !== -1) {
          var endIndex = assertion.indexOf("}", startIndex);
          variables.push(assertion.substring(startIndex + 1, endIndex));
          assertion = assertion.substring(endIndex + 1).trim();
        }
      } while (startIndex !== -1);

      if (variables.length) {
        return _.uniq(variables);
      }

      return [];
    }
    /**
     * validate if ivr test are valid,
     * this method should be called after global configuration is load
     * @param {testSuite} suite - test suite will all the tests
     */

  }, {
    key: "validateIvrTests",
    value: function validateIvrTests(suite) {
      var platform = suite.platform;

      if (platform === "twilio" || platform === "phone") {
        var tests = suite.tests;

        for (var i = 0; i < tests.length; i++) {
          var test = tests[i];

          for (var j = 0; j < test.interactions.length; j++) {
            var interaction = test.interactions[j];
            var hasFinishOnPhrase = interaction.expressions.some(e => e.path.includes("finishOnPhrase"));
            var hasListeningTimeout = interaction.expressions.some(e => e.path.includes("listeningTimeout"));

            if (j < test.interactions.length - 1 && !hasFinishOnPhrase && !hasListeningTimeout) {
              throw ParserError.error(suite.fileName, "missing required parameter 'finishOnPhrase' or 'listeningTimeout'", interaction.lineNumber);
            }
          }
        }
      }
    }
  }]);

  return TestParser;
}();

module.exports = TestParser;