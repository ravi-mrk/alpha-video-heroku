function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* eslint-disable no-unused-vars */
// Class that must be implemented by any test method
// Invoker contains the template methods that must implemented
// The life-cycle of an invoker is for a test suite - it is thrown away at the end of executing the suite
exports.Invoker = /*#__PURE__*/function () {
  function Invoker(runner) {
    _classCallCheck(this, Invoker);

    this._runner = runner;
  } // Takes a set of interactions and returns responses from the app
  // Takes multiple interactions because some implementations work better in batch


  _createClass(Invoker, [{
    key: "invokeBatch",
    value: function () {
      var _invokeBatch = _asyncToGenerator(function* (interactions) {
        return Promise.reject("This method must be implemented if batch mode is supported");
      });

      function invokeBatch(_x) {
        return _invokeBatch.apply(this, arguments);
      }

      return invokeBatch;
    }()
  }, {
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator(function* (interaction) {
        return Promise.reject("This method must be implemented");
      });

      function invoke(_x2) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }, {
    key: "after",
    value: function after(testSuite) {// Do whatever is necessary on teardown of the invoker
    }
  }, {
    key: "afterTest",
    value: function afterTest(test) {// Do whatever is necessary after the test
    }
  }, {
    key: "batchSupported",
    value: function batchSupported() {
      return false;
    }
  }, {
    key: "before",
    value: function before(testSuite) {// Do whatever is necessary to setup the invoker for the test suite
    }
  }, {
    key: "beforeTest",
    value: function beforeTest(test) {// Do whatever is necessary to setup the invoker for the test
    }
  }]);

  return Invoker;
}(); // InvokerResponse contains the response elements that should be handled
// Values that are available listed in an array in the provides method


exports.InvokerResponse = /*#__PURE__*/function () {
  function InvokerResponse(interaction, sourceJSON) {
    _classCallCheck(this, InvokerResponse);

    this._interaction = interaction;
    this._sourceJSON = sourceJSON;
    this._errorOnProcess = false;
    this._error = undefined;
  }

  _createClass(InvokerResponse, [{
    key: "cardContent",
    value: function cardContent() {
      throw unsupportedError();
    }
  }, {
    key: "cardImageURL",
    value: function cardImageURL() {
      throw unsupportedError();
    }
  }, {
    key: "cardTitle",
    value: function cardTitle() {
      throw unsupportedError();
    }
  }, {
    key: "prompt",
    value: function prompt() {
      throw unsupportedError();
    }
  }, {
    key: "reprompt",
    value: function reprompt() {
      throw unsupportedError();
    }
  }, {
    key: "sessionEnded",
    value: function sessionEnded() {
      throw unsupportedError();
    } // Injects the core fields into the JSON

  }, {
    key: "inject",
    value: function inject() {
      if (!this.json) {
        return;
      }

      this.json.cardContent = this.cardContent();
      this.json.cardImageURL = this.cardImageURL();
      this.json.cardTitle = this.cardTitle();
      this.json.prompt = this.prompt();
      this.json.reprompt = this.reprompt();
      this.json.sessionEnded = this.sessionEnded();
    } // Returns whether or not the specific JSON path is supported by this response
    // If a field is not supported, assertions referencing it are ignored
    // Defaults to returning true for the core fields

  }, {
    key: "supported",
    value: function supported(jsonPath) {
      return ["cardContent", "cardImageURL", "cardTitle", "prompt", "reprompt"].includes(jsonPath);
    } // Return true if assertions for a particular JSON path should be case-insensitive

  }, {
    key: "ignoreCase",
    value: function ignoreCase(jsonPath) {
      return false;
    }
  }, {
    key: "interaction",
    get: function () {
      return this._interaction;
    }
  }, {
    key: "json",
    get: function () {
      return this._sourceJSON;
    }
  }, {
    key: "error",
    get: function () {
      return this._error;
    },
    set: function (value) {
      this._error = value;
    }
  }, {
    key: "errorOnProcess",
    get: function () {
      return this._errorOnProcess;
    },
    set: function (value) {
      this._errorOnProcess = value;
    }
  }]);

  return InvokerResponse;
}();

function unsupportedError() {
  return new Error("Unimplemented function - should either be implemented or not listed under supported");
}