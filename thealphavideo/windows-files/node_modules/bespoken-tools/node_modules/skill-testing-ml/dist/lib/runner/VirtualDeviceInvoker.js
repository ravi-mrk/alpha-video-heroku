function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _ = require("lodash");

var chalk = require("chalk");

var CONSTANTS = require("../util/Constants");

var debug = require("../util/Debug");

var FrameworkError = require("../util/FrameworkError");

var Invoker = require("./Invoker").Invoker;

var InvokerResponse = require("./Invoker").InvokerResponse;

var LoggingErrorHelper = require("../util/LoggingErrorHelper");

var sleep = require("../util/Util").sleep;

var Util = require("../util/Util");

var VirtualDevice = require("virtual-device-sdk").VirtualDevice;

var maxResponseWaitTime;
var waitInterval;

module.exports = /*#__PURE__*/function (_Invoker) {
  _inherits(VirtualDeviceInvoker, _Invoker);

  var _super = _createSuper(VirtualDeviceInvoker);

  function VirtualDeviceInvoker(runner) {
    _classCallCheck(this, VirtualDeviceInvoker);

    return _super.call(this, runner);
  }

  _createClass(VirtualDeviceInvoker, [{
    key: "batchSupported",
    value: function batchSupported() {
      return true;
    }
  }, {
    key: "before",
    value: function before(testSuite) {
      var locale = testSuite.locale || undefined;
      var voiceId = testSuite.voiceId || undefined;
      var virtualDeviceToken = testSuite.virtualDeviceToken;
      var virtualDeviceAsyncMode = testSuite.asyncMode;
      this.asyncMode = virtualDeviceAsyncMode;
      var deviceLocation = testSuite.deviceLocation || {};
      var stt = testSuite.stt || undefined;
      var screenMode = testSuite.screenMode;
      var client = testSuite.client;
      var projectId = testSuite.projectId;
      var phoneNumber = testSuite.phoneNumber;
      var platform = testSuite.platform;
      var includeRaw = testSuite.includeRaw;
      var replyTimeout = testSuite.replyTimeout;
      this.debugMode = includeRaw;
      var extraParameters = testSuite.extraParameters || {};
      extraParameters = Util.cleanObject(extraParameters);
      maxResponseWaitTime = testSuite.maxAsyncE2EResponseWaitTime;
      waitInterval = testSuite.asyncE2EWaitInterval;

      if (!virtualDeviceToken) {
        throw new FrameworkError("A valid virtualDeviceToken property must be defined either in the testing.json or the YML test file under the config element");
      }

      if ((virtualDeviceToken.includes("twilio") || virtualDeviceToken.includes("phone")) && !phoneNumber) {
        throw new FrameworkError("A valid phoneNumber property must be defined for IVR tests in the " + "testing.json or the YML test file under the config element");
      }

      if (replyTimeout * 1000 > maxResponseWaitTime) {
        throw new FrameworkError("The replyTimeout property must be less than or equal to the maxAsyncE2EResponseWaitTime property in the " + "testing.json or the YML test file under the config element");
      }

      var lat = Util.cleanValue(deviceLocation.lat);
      var lng = Util.cleanValue(deviceLocation.lng);
      var configuration = {
        asyncMode: virtualDeviceAsyncMode,
        client,
        locale,
        locationLat: lat,
        locationLong: lng,
        phoneNumber,
        platform,
        projectId,
        replyTimeout,
        screenMode,
        stt,
        token: virtualDeviceToken,
        voiceID: voiceId
      };
      configuration = _.assign(extraParameters, configuration);
      this._recordCall = _.get(extraParameters, "recordCall", false);
      debug("Virtual Device instance creation: ", configuration);
      this._virtualDevice = new VirtualDevice(configuration);

      if (virtualDeviceToken.startsWith("twilio-") || virtualDeviceToken.startsWith("phone-")) {
        debug("Setting virtual device url: https://virtual-device-twilio.bespoken.io");
        this._virtualDevice.baseURL = "https://virtual-device-twilio.bespoken.io";
      }

      if (!process.env.VIRTUAL_DEVICE_BASE_URL && testSuite.virtualDeviceBaseURL) {
        debug("Setting virtual device url: ", testSuite.virtualDeviceBaseURL);
        this._virtualDevice.baseURL = testSuite.virtualDeviceBaseURL;
      }

      var homophones = testSuite.homophones;

      if (homophones) {
        var keys = Object.keys(homophones);

        for (var key of keys) {
          this._virtualDevice.addHomophones(key, homophones[key]);
        }
      }
    }
  }, {
    key: "convertInteractionsToMessages",
    value: function convertInteractionsToMessages(interactions) {
      var messages = []; // Keep an array of the actual interactions sent, as some may be skipped

      var messageInteractions = [];

      var _loop = function (interaction) {
        var utterance = interaction.utterance;
        var message = {
          phrases: [],
          text: utterance
        };
        messageInteractions.push(interaction); // Add request expressions to the body of the JSON
        // Can be used on the server to override properties

        message.settings = {};

        if (interaction.expressions) {
          interaction.expressions.map(expression => {
            var startPath = expression.path.startsWith("set ") ? "set ".length : "request.".length; // Remove the prefix of the path

            var path = expression.path.substring(startPath);
            message.settings[path] = expression.value;
          });
        }

        if (interaction.assertions) {
          (function () {
            var isVariable = value => value && value.indexOf && value.indexOf("{") >= 0;

            for (var assertion of interaction.assertions) {
              // If this is a check on the prompt or the transcript
              //  we add the expected value as a phrase - this helps with speech recognition
              if ((assertion.path === "prompt" || assertion.path === "transcript") && (assertion.operator === "==" || assertion.operator === "=~")) {
                // Need to check if this is an array - the prompt assertions can specify a collection of strings
                if (Array.isArray(assertion.value)) {
                  var phrases = assertion.value.filter(value => !isVariable(value));
                  message.phrases = message.phrases.concat(phrases);
                } else {
                  if (!isVariable(assertion.value)) {
                    message.phrases.push(assertion.value);
                  }
                }
              }
            }
          })();
        }

        messages.push(message);
      };

      for (var interaction of interactions) {
        _loop(interaction);
      }

      return {
        messageInteractions,
        messages
      };
    }
  }, {
    key: "invokeBatch",
    value: function () {
      var _invokeBatch = _asyncToGenerator(function* (interactions) {
        var _this = this;

        var {
          messages,
          messageInteractions
        } = this.convertInteractionsToMessages(interactions);

        this._virtualDevice.clearFilters();

        this._virtualDevice.addFilter( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator(function* (request) {
            // For a batch response we consider only the first interaction for the filter to avoid adding multiple
            // times the same filter for only one request
            yield _this._runner.filterRequest(interactions[0], request);
          });

          return function (_x2) {
            return _ref.apply(this, arguments);
          };
        }());

        var results = [];
        var errorOnProcess = undefined;
        var errorObject = undefined;
        var enableDebug = this.debugMode;

        if (messages.length > 0) {
          try {
            var response = yield this._virtualDevice.batchMessage(messages, enableDebug);
            results = response.results || [];

            if (response.error) {
              ({
                errorOnProcess,
                errorObject,
                results
              } = this.parseError(response, messages.length));
            }
          } catch (error) {
            ({
              errorOnProcess,
              errorObject,
              results
            } = this.parseError(error, messages.length));
          }
        }

        var responses = [];

        for (var i = 0; i < results.length; i++) {
          var virtualDeviceResponse = new VirtualDeviceResponse(messageInteractions[i], results[i]);

          if (errorOnProcess || results[i].error) {
            virtualDeviceResponse.errorOnProcess = errorOnProcess || results[i].error.message;
            virtualDeviceResponse.error = errorOnProcess ? errorObject : Object.assign({}, errorObject, results[i].error);
            responses.push(virtualDeviceResponse);
            break;
          }

          responses.push(virtualDeviceResponse);
        }

        if (this._virtualDevice.waitForSessionToEnd) yield this._virtualDevice.waitForSessionToEnd();
        return responses;
      });

      function invokeBatch(_x) {
        return _invokeBatch.apply(this, arguments);
      }

      return invokeBatch;
    }()
  }, {
    key: "sequentialInvocation",
    value: function () {
      var _sequentialInvocation = _asyncToGenerator(function* (interaction) {
        var _this2 = this;

        if (!interaction.utterance) {
          return;
        }

        var {
          messages
        } = this.convertInteractionsToMessages([interaction]);
        var message = messages[0];

        this._virtualDevice.clearFilters();

        this._virtualDevice.addFilter( /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator(function* (request) {
            yield _this2._runner.filterRequest(interaction, request);
          });

          return function (_x4) {
            return _ref2.apply(this, arguments);
          };
        }());

        var results = new Array(1);
        var errorOnProcess = undefined;
        var errorObject = {
          error_category: "system"
        };

        try {
          var response = yield this._virtualDevice.batchMessage([message], this.debugMode);
          results = response.results || [];

          if (response.error) {
            ({
              errorOnProcess,
              errorObject,
              results
            } = this.parseError(response, 1));
          }
        } catch (error) {
          ({
            errorOnProcess,
            errorObject,
            results
          } = this.parseError(error, 1));
        }

        var virtualDeviceResponse = new VirtualDeviceResponse(interaction, results[0]);

        if (errorOnProcess) {
          virtualDeviceResponse.errorOnProcess = errorOnProcess;
          virtualDeviceResponse.error = errorObject;
          return virtualDeviceResponse;
        } else {
          if (results[0] && results[0].error) {
            virtualDeviceResponse.error = Object.assign({}, errorObject, results[0].error);
            virtualDeviceResponse.errorOnProcess = results[0].error.message;
          }
        }

        return virtualDeviceResponse;
      });

      function sequentialInvocation(_x3) {
        return _sequentialInvocation.apply(this, arguments);
      }

      return sequentialInvocation;
    }()
  }, {
    key: "batchAsyncInvocation",
    value: function () {
      var _batchAsyncInvocation = _asyncToGenerator(function* (interaction, interactions) {
        var _this3 = this;

        var {
          messages,
          messageInteractions
        } = this.convertInteractionsToMessages(interactions);
        var asyncBatchResult;
        var errorObject = undefined;
        var errorOnProcess = undefined;
        var rawVirtualDeviceResponse;
        var totalTimeWaited = 0;
        var isCompleted = false;
        var interactionIndex = 0;
        var isLastItemFromResults = false;
        var maxResponseWaitTimePerInteraction = maxResponseWaitTime;
        var waitIntervalPerInteraction = waitInterval;

        if (interaction.hasPause) {
          var pause = interaction.pauseSeconds * 1000;
          maxResponseWaitTimePerInteraction += pause;
          waitIntervalPerInteraction = pause > waitInterval ? pause : waitInterval;
          debug("Updating maxResponseWaitTime and waitInterval: ", maxResponseWaitTimePerInteraction, waitIntervalPerInteraction);
        }

        try {
          this._virtualDevice.clearFilters();

          this._virtualDevice.addFilter( /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator(function* (request) {
              yield _this3._runner.filterRequest(interaction, request);
            });

            return function (_x7) {
              return _ref3.apply(this, arguments);
            };
          }());

          interactionIndex = messageInteractions.findIndex(messageInteraction => {
            return messageInteraction.lineNumber === interaction.lineNumber;
          }); // This is the first interaction, we send the whole list of interactions and get the conversation id

          if (interactionIndex === 0 || !this.currentConversation) {
            asyncBatchResult = yield this._virtualDevice.batchMessage(messages, this.debugMode);

            if (asyncBatchResult.error) {
              throw asyncBatchResult;
            }

            this.currentConversation = asyncBatchResult.conversation_id;

            this._runner.emit("conversation_id", undefined, this.currentConversation, undefined);

            debug({
              "conversation_id": this.currentConversation
            });
          } // We query every 5 seconds to see if we got the current interaction results


          var isCurrentInteractionTimeoutExceed = false;

          do {
            // we query first before waiting because after the first interaction this ensure to get the responses
            // as soon as we can to the user, instead of adding 5 obligatory seconds every time if we got more than
            // one response in the same result
            var _virtualDeviceResponse = yield this._virtualDevice.getConversationResults(this.currentConversation);

            var processedInteractions = _virtualDeviceResponse.results || [];

            if (_virtualDeviceResponse.error) {
              ({
                errorOnProcess,
                errorObject
              } = this.parseError(_virtualDeviceResponse, messages.length));
            }

            if (processedInteractions.length) {
              if (processedInteractions[interactionIndex]) {
                // We have reached the interaction that we have at the moment
                rawVirtualDeviceResponse = processedInteractions[interactionIndex];
              }
            }

            isCompleted = ["COMPLETED", "ERROR"].indexOf(_virtualDeviceResponse.status) > -1;
            isLastItemFromResults = isCompleted && interactionIndex === processedInteractions.length - 1;

            if (totalTimeWaited >= maxResponseWaitTimePerInteraction) {
              isCurrentInteractionTimeoutExceed = true;
            }

            if (!isCurrentInteractionTimeoutExceed && !rawVirtualDeviceResponse) {
              yield sleep(waitIntervalPerInteraction);
              totalTimeWaited += waitIntervalPerInteraction;
            }
          } while (!rawVirtualDeviceResponse && !isCurrentInteractionTimeoutExceed && !isCompleted);

          if (isCurrentInteractionTimeoutExceed && !rawVirtualDeviceResponse) {
            var message = "Timeout exceeded while waiting for the interaction response";
            errorObject = {
              error_category: "system",
              message
            };
            errorOnProcess = message;
          }
        } catch (error) {
          var parsedError = this.parseError(error);
          errorOnProcess = parsedError.errorOnProcess;
          errorObject = parsedError.errorObject;

          if (parsedError && parsedError.results && parsedError.results.length > interactionIndex) {
            rawVirtualDeviceResponse = parsedError.results[interactionIndex];
          }
        }

        var virtualDeviceResponse = new VirtualDeviceResponse(interaction, rawVirtualDeviceResponse);
        virtualDeviceResponse.isLastItemFromResults = isLastItemFromResults;
        var setError = false;

        if (!rawVirtualDeviceResponse) {
          setError = true;
        } else if (Object.keys(rawVirtualDeviceResponse).length === 0) {
          setError = true;
        } // only set error when the response is null


        if (errorOnProcess && setError) {
          virtualDeviceResponse.errorOnProcess = errorOnProcess;
          virtualDeviceResponse.error = errorObject;
        }

        return virtualDeviceResponse;
      });

      function batchAsyncInvocation(_x5, _x6) {
        return _batchAsyncInvocation.apply(this, arguments);
      }

      return batchAsyncInvocation;
    }()
  }, {
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator(function* (interaction, interactions) {
        if (this.asyncMode) {
          return this.batchAsyncInvocation(interaction, interactions);
        } else {
          return this.sequentialInvocation(interaction);
        }
      });

      function invoke(_x8, _x9) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }, {
    key: "getErrorValues",
    value: function getErrorValues(parsedError) {
      var errorOnProcess;
      var errorObject = {};
      var results = [];

      if (parsedError.error) {
        errorOnProcess = parsedError.error;
        errorObject.message = errorOnProcess;
      } else {
        errorOnProcess = `${parsedError}`;
        errorObject.message = errorOnProcess;
      }

      if (parsedError.error_category || parsedError.errorCategory) {
        errorObject.error_category = parsedError.error_category || parsedError.errorCategory;
      }

      if (parsedError.error_code || parsedError.errorCode) {
        errorObject.error_code = parsedError.error_code || parsedError.errorCode;
      }

      if (parsedError.results) {
        results = parsedError.results;
      }

      return {
        errorObject,
        errorOnProcess,
        results
      };
    }
  }, {
    key: "parseError",
    value: function parseError(error, numberOfMessages) {
      var errorObject = {
        error_category: "system",
        error_code: 500,
        message: "Error on virtual device"
      };
      var errorOnProcess;
      var results = [];
      var errorLog = ""; // error could a json {results, error, error_category, error_code}
      // or a plain string
      // or it could be an exception

      if (typeof error === "object") {
        if (Util.isErrorObject(error)) {
          errorOnProcess = "ERROR - " + (error.code || error.message) + " \nRaw message: " + error.stack;
          errorObject.message = errorOnProcess;
          errorLog = error.stack;
        } else {
          var errorValues = this.getErrorValues(error);
          errorOnProcess = errorValues.errorOnProcess;
          errorObject = Object.assign({}, errorObject, errorValues.errorObject);
          results = errorValues.results;
        }
      } else if (typeof error === "string") {
        try {
          var parsedError = JSON.parse(error);

          var _errorValues = this.getErrorValues(parsedError);

          errorOnProcess = _errorValues.errorOnProcess;
          errorObject = Object.assign({}, errorObject, _errorValues.errorObject);
          results = _errorValues.results;
        } catch (parseException) {
          errorOnProcess = error;
          errorObject.message = error;
        }
      }

      LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
      LoggingErrorHelper.error("bst-test", errorLog || errorOnProcess);
      LoggingErrorHelper.error("bst-test", JSON.stringify(errorObject));
      results = results.length > 0 ? results : new Array(numberOfMessages).fill({});
      return {
        errorObject,
        errorOnProcess,
        results
      };
    }
  }, {
    key: "stopProcess",
    value: function () {
      var _stopProcess = _asyncToGenerator(function* () {
        return yield this._virtualDevice.stopConversation(this.currentConversation);
      });

      function stopProcess() {
        return _stopProcess.apply(this, arguments);
      }

      return stopProcess;
    }()
  }, {
    key: "afterTest",
    value: function () {
      var _afterTest = _asyncToGenerator(function* (test) {
        if (!this._recordCall) {
          return;
        }

        var printMessage = response => {
          if (response && response.callAudioURL) {
            // eslint-disable-next-line no-console
            console.log(chalk.cyan("Test completed: " + test.description)); // eslint-disable-next-line no-console

            console.log(chalk.cyan("Call recording URL: " + response.callAudioURL));
            return true;
          }

          return false;
        }; // takes a few seconds to get the recorded call url, we try a few times


        yield sleep(2000);
        var virtualDeviceResponse = yield this._virtualDevice.getConversationResults(this.currentConversation);
        if (printMessage(virtualDeviceResponse)) return;
        yield sleep(4000);
        virtualDeviceResponse = yield this._virtualDevice.getConversationResults(this.currentConversation);
        printMessage(virtualDeviceResponse);
      });

      function afterTest(_x10) {
        return _afterTest.apply(this, arguments);
      }

      return afterTest;
    }()
  }, {
    key: "asyncMode",
    get: function () {
      return this._asyncMode;
    },
    set: function (asyncMode) {
      this._asyncMode = asyncMode;
    }
  }, {
    key: "debugMode",
    get: function () {
      return this._debugMode;
    },
    set: function (debugMode) {
      this._debugMode = debugMode;
    }
  }, {
    key: "currentConversation",
    get: function () {
      return this._currentConversation;
    },
    set: function (currentConversation) {
      this._currentConversation = currentConversation;
    }
  }]);

  return VirtualDeviceInvoker;
}(Invoker);

var VirtualDeviceResponse = /*#__PURE__*/function (_InvokerResponse) {
  _inherits(VirtualDeviceResponse, _InvokerResponse);

  var _super2 = _createSuper(VirtualDeviceResponse);

  function VirtualDeviceResponse(interaction, sourceJSON) {
    _classCallCheck(this, VirtualDeviceResponse);

    return _super2.call(this, interaction, sourceJSON);
  }

  _createClass(VirtualDeviceResponse, [{
    key: "cardContent",
    value: function cardContent() {
      return _.get(this.json, "card.textField");
    }
  }, {
    key: "cardImageURL",
    value: function cardImageURL() {
      return _.get(this.json, "card.imageURL");
    }
  }, {
    key: "cardTitle",
    value: function cardTitle() {
      return _.get(this.json, "card.mainTitle");
    }
  }, {
    key: "prompt",
    value: function prompt() {
      return _.get(this.json, "transcript");
    }
  }, {
    key: "reprompt",
    value: function reprompt() {
      return undefined;
    }
  }, {
    key: "sessionEnded",
    value: function sessionEnded() {
      return undefined;
    }
  }, {
    key: "supported",
    value: function supported(jsonPath) {
      var platform = _.get(this._interaction, "test.testSuite.platform");

      var ignorePropertiesRaw = _.get(this._interaction, "test.testSuite.ignoreProperties");

      var testType = _.get(ignorePropertiesRaw, `${platform}.type`);

      var ignoredProperties = [];

      if (testType == "e2e") {
        var paths = _.get(ignorePropertiesRaw, `${platform}.paths`);

        if (paths && paths.length) ignoredProperties = paths.split(",").map(x => x.trim());
      }

      if (platform === CONSTANTS.PLATFORM.google) {
        ignoredProperties.push("card.type");
        ignoredProperties.push("streamURL");
      }

      if (ignoredProperties.includes(jsonPath)) {
        return false;
      }

      return true;
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "ignoreCase",
    value: function ignoreCase(jsonPath) {
      return ["prompt", "transcript"].includes(jsonPath);
    }
  }]);

  return VirtualDeviceResponse;
}(InvokerResponse);