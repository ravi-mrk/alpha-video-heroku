"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = require("./global");
var string_util_1 = require("./string-util");
var logging_helper_1 = require("./logging-helper");
var net = require("net");
var Logger = "SOCKET";
var SocketHandler = (function () {
    function SocketHandler(socket, onMessage) {
        this.socket = socket;
        this.onMessage = onMessage;
        this.buffer = Buffer.from("");
        this.onCloseCallback = null;
        this.connected = true;
        var self = this;
        this.onDataCallback = function (data) {
            if (!self.handleData(data)) {
                this.socket.destroy("Error handling data - closing socket");
            }
        };
        this.socket.on("data", this.onDataCallback);
        this.socket.on("error", function (e) {
            if (self.connected) {
                logging_helper_1.LoggingHelper.error(Logger, "SocketError From: " + self.remoteEndPoint() + " Error: " + e.code + " Message: " + e.message);
            }
        });
        this.socket.on("close", function () {
            if (self.connected) {
                if (self.onCloseCallback != null) {
                    self.onCloseCallback();
                }
                else {
                    logging_helper_1.LoggingHelper.debug(Logger, "Socket closed");
                }
            }
        });
    }
    SocketHandler.connect = function (host, port, onConnect, onMessage) {
        var socket = new net.Socket();
        var handler = new SocketHandler(socket, onMessage);
        handler.connected = false;
        socket.connect(port, host, function () {
            handler.connected = true;
            onConnect();
        });
        socket.on("error", function (error) {
            if (!handler.connected) {
                onConnect(error);
            }
        });
        return handler;
    };
    SocketHandler.prototype.handleData = function (data) {
        if (data !== null) {
            try {
                this.buffer = Buffer.concat([this.buffer, data]);
            }
            catch (e) {
                console.error("Buffer allocation error existing " + this.buffer.length + " new: " + data.length + " error: " + e.message);
                return false;
            }
        }
        var delimiterIndex = this.buffer.indexOf(global_1.Global.MessageDelimiter);
        if (delimiterIndex > -1) {
            var messageIDIndex = delimiterIndex - global_1.Global.MessageIDLength;
            var badMessage = messageIDIndex < 0;
            var message = this.buffer.slice(0, messageIDIndex);
            var messageIDString = this.buffer.slice(delimiterIndex - global_1.Global.MessageIDLength, delimiterIndex).toString();
            var messageID = parseInt(messageIDString);
            if (isNaN(messageID) || (messageID + "").length < 13) {
                badMessage = true;
            }
            if (badMessage) {
                logging_helper_1.LoggingHelper.error(Logger, "Bad message received: " + this.buffer.toString());
            }
            else {
                var socketMessage = new SocketMessage(message, messageID);
                logging_helper_1.LoggingHelper.debug(Logger, "DATA READ " + this.remoteEndPoint() + " ID: " + messageID + " MSG: "
                    + string_util_1.StringUtil.prettyPrint(socketMessage.messageForLogging()));
                this.onMessage(socketMessage);
            }
            this.buffer = this.buffer.slice(delimiterIndex + global_1.Global.MessageDelimiter.length);
            if (this.buffer.toString().indexOf(global_1.Global.MessageDelimiter) !== -1) {
                return this.handleData(null);
            }
        }
        return true;
    };
    SocketHandler.prototype.send = function (socketMessage) {
        if (this.socket === null) {
            logging_helper_1.LoggingHelper.warn(Logger, "Writing message to closed socket: " + socketMessage.getMessageID());
            return;
        }
        var dataSent = socketMessage.isString() ? socketMessage.asString() : "< Binary Data >";
        logging_helper_1.LoggingHelper.debug(Logger, "DATA SENT " + this.remoteEndPoint() + " SEQUENCE: " + socketMessage.getMessageID() + " " + string_util_1.StringUtil.prettyPrint(dataSent));
        this.socket.write(socketMessage.getFullMessage(), null);
    };
    SocketHandler.prototype.remoteAddress = function () {
        return this.socket.remoteAddress;
    };
    SocketHandler.prototype.remoteEndPoint = function () {
        if (this.socket === null) {
            return "";
        }
        return this.socket.remoteAddress + ":" + this.socket.remotePort;
    };
    SocketHandler.prototype.disconnect = function () {
        if (this.isOpen()) {
            this.socket.end();
            this.socket = null;
        }
    };
    SocketHandler.prototype.isOpen = function () {
        return this.socket != null;
    };
    return SocketHandler;
}());
exports.SocketHandler = SocketHandler;
var SocketMessage = (function () {
    function SocketMessage(message, sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
        this.message = Buffer.from("");
        if (typeof message === "string") {
            this.message = Buffer.concat([this.message, Buffer.from(message)]);
        }
        else {
            this.message = Buffer.concat([this.message, message]);
        }
    }
    SocketMessage.prototype.getMessageID = function () {
        return this.sequenceNumber ? this.sequenceNumber : new Date().getTime();
    };
    SocketMessage.prototype.asString = function () {
        return this.message.toString();
    };
    SocketMessage.prototype.isString = function () {
        return !/[\x00-\x1F]/.test(this.asString());
    };
    SocketMessage.prototype.isJSON = function () {
        try {
            JSON.parse(this.asString());
            return true;
        }
        catch (error) {
            return false;
        }
    };
    SocketMessage.prototype.asJSON = function () {
        return JSON.parse(this.asString());
    };
    SocketMessage.prototype.messageForLogging = function () {
        return this.isString() ? this.asString() : "< Binary Data>";
    };
    SocketMessage.prototype.getMessage = function () {
        return this.message;
    };
    SocketMessage.prototype.getFullMessage = function () {
        var messageID = this.getMessageID();
        return Buffer.concat([this.message, Buffer.from(messageID.toString()), Buffer.from(global_1.Global.MessageDelimiter)]);
    };
    SocketMessage.prototype.contains = function (stringToFind) {
        return this.asString().indexOf(stringToFind) > -1;
    };
    SocketMessage.prototype.startsWith = function (stringToFind) {
        return this.asString().startsWith(stringToFind);
    };
    return SocketMessage;
}());
exports.SocketMessage = SocketMessage;
//# sourceMappingURL=socket-handler.js.map